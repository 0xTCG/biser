from hit import Hit
from time import timing


def generate_anchors(h, KMER_SIZE: Static[int] = 10):
  x, y = h.x.chr[h.x.start:h.x.end], h.y.chr[h.y.start:h.y.end]

  ref_hashes = {}
  for pos, kmer in y.kmers_with_pos(1, KMER_SIZE):
    ref_hashes.setdefault(int(kmer), []).append(pos)

  slide = [-1] * (len(x) + len(y))
  for xi, kmer in x.kmers_with_pos(1, KMER_SIZE):
    matches = ref_hashes.get(int(kmer), [])
    if not 0 < len(matches) < 1000:
      continue
    for yi in matches:
      d = len(x) + yi - xi
      if (h.same_chr() and abs(h.y.start + yi - h.x.start - xi) <= KMER_SIZE) or xi < slide[d]:
        continue
      ext = KMER_SIZE
      while (
        xi + ext < len(x) and yi + ext < len(y) and
        x[xi + ext] != s'N' and y[yi + ext] != s'N' and x[xi + ext] == y[yi + ext]
      ):
        ext += 1
      yield (h.x.start + xi, h.y.start + yi, ext)
      slide[d] = xi + ext


# def fast_heuristic_chain(
#   hits,
#   score,
# ):
#   """
#   Finds all local chains with from the list of anchors.
#   Each anchor is a tuple of {(start_reference, start_query, anchor_len)}.
#   Returns a list of chains where each chain is a list of indices from the {anchors} list.
#   Complexity: O(n log n) where {n = len(anchors)}.
#   """

#   MATCH = 10
#   MISMATCH = 1
#   GAP = 0.5
#   GAPOPEN = 100 # try to approximate WGAC
#   MIN_READ = 900 # minimal refined read size
#   SIDE_ALIGN = 500
#   MAX_GAP = 10 * 1024 # max gap during refining process

#   if not hits:
#     return
#   # Construct a tree from y-points (query)
#   xs = [(h.x.start, i) for i, h in enumerate(hits)]
#   xs += [(h.x.end, i) for i, h in enumerate(hits)]
#   ys = [(h.y.end - 1, i) for i, h in enumerate(hits)] # inclusive bound
#   max_x, max_y = max(xs)[0], max(ys)[0] + 1
#   tree = PrioritySearchTree(ys, (0, 0))

#   # Iterate through the sorted x-points (reference)
#   dp = [(0, i) for i in range(len(hits))]  # DP table
#   prev = [-1] * len(hits)  # pointer to the previous element in chain
#   deactivate_bound = 0
#   xs.sort()
#   for xi, (x, ai) in enumerate(xs):  # (x.x.first, i)
#     if x == hits[ai].x.start:  # left interval point
#       while deactivate_bound < xi:
#         d = xs[deactivate_bound][1]
#         if xs[deactivate_bound][0] == hits[d].x.end:
#           if hits[ai].x.start - hits[d].x.end <= MAX_GAP:
#             break
#           tree.deactivate((hits[d].y.end - 1, d))
#         deactivate_bound += 1

#       w = int(score[ai])
#       # Find the highest scoring segment that precedes the current one
#       j = tree.rmq((hits[ai].y.start - MAX_GAP, 0), (hits[ai].y.start - 1, len(hits)))
#       if j != -1 and tree.score[j] != MIN_SCORE:
#         j = ys[j][1]
#         gap = int(GAPOPEN + GAP * (hits[ai].x.start - hits[j].x.end + hits[ai].y.start - hits[j].y.end))
#         if w + dp[j][0] - gap > 0:
#           dp[ai] = (w + dp[j][0] - gap, dp[ai][1])
#           prev[ai] = j
#         else:
#           dp[ai] = (w, dp[ai][1])
#       else:
#         dp[ai] = (w, dp[ai][1])
#     else:
#       gap = int(GAPOPEN + GAP * (max_x + 1 - hits[ai].x.end + max_y + 1 - hits[ai].y.end))
#       tree.activate((hits[ai].y.end - 1, ai), dp[ai][0] - gap)
#   dp.sort(reverse=True)


def refine(orig_h, hits):
  MATCH = 10
  MISMATCH = 1
  GAP = 0.5
  GAPOPEN = 100 # try to approximate WGAC
  MIN_READ = 900 # minimal refined read size
  SIDE_ALIGN = 500
  MAX_GAP = 10 * 1024 # max gap during refining process
  MAX_ITER = 100

  hits.sort()
  #(lambda h: (h.x.chr, h.y.chr, h.x.end, h.x.start, h.y))
  score = [h.score(MATCH, -MISMATCH, -GAP) for h in hits]
  dp, prev = [0.0] * len(hits), [-1] * len(hits)
  maxes = []

  print(f"[refine] hs= {len(hits)}")
  with timing('[refine] Chain'):
    for ai, a in enumerate(hits):
      if orig_h.same_chr():
        qo = min(a.x.end, a.y.end) - max(a.x.start, a.y.start)
        if max(a.y.end - a.y.start, a.x.end - a.x.start) - max(qo, 0) < SIDE_ALIGN:
          continue # no gap between
      dp[ai] = score[ai]

      # https://academic.oup.com/bioinformatics/article/34/18/3094/4994778 sec. 2.1.1
      for it in range(min(ai, ai)):
        aj = ai - it - 1
        c, p = hits[ai], hits[aj]
        c_xs = p.x.end if c.x.start < p.x.end else c.x.start
        c_ys = p.y.end if c.y.start < p.y.end else c.y.start
        if p.x.end >= c.x.end or p.y.end >= c.y.end or p.y.start >= c.y.start:
          continue

        mi, ma = min(c_xs - p.x.end, c_ys - p.y.end), max(c_xs - p.x.end, c_ys - p.y.end)
        if ma >= MAX_GAP:
          continue
        if orig_h.same_chr() and max(0, min(c_xs, c_ys) - max(p.x.end, p.y.end)) >= 1:
          continue # no gap between
        sc = dp[aj] + score[ai] - MISMATCH * mi - GAPOPEN - GAP * (ma - mi)
        if sc >= dp[ai]:
          dp[ai], prev[ai] = sc, aj
      maxes.append((dp[ai], ai))
  maxes.sort(reverse=True)

  used = [False] * len(hits)
  results = []
  for d, maxi in maxes:
    if d == 0: break
    if used[maxi]: continue

    path = []
    while maxi != -1 and not used[maxi]:
      path.append(maxi)
      used[maxi] = True
      maxi = prev[maxi]
    path = path[::-1]

    est_size = hits[path[0]].span()
    for i in range(1, len(path)):
      est_size += hits[path[i]].span()
      est_size += max(
        hits[path[i]].x.start - hits[path[i - 1]].x.end,
        hits[path[i]].y.start - hits[path[i - 1]].y.end
      )
    if est_size < MIN_READ - SIDE_ALIGN:
      continue

    xs, xe = hits[path[0]].x.start, hits[path[-1]].x.end
    ys, ye = hits[path[0]].y.start, hits[path[-1]].y.end
    if any(
      xe - xs - max(0, min(xe, r.x.end) - max(xs, r.x.start)) < SIDE_ALIGN and
      ye - ys - max(0, min(ye, r.y.end) - max(ys, r.y.start)) < SIDE_ALIGN
      for r in results
    ):
      continue

    h = Hit(orig_h, [hits[pi] for pi in path], SIDE_ALIGN)
    if h.span() >= MIN_READ:
      yield h
      results.append(h)
