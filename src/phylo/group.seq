from sd2 import *
from tree import *
from time import *

# this is script for creating distance matrix between all SDs

def getIntTree(path, wgac, coordinates):
    dict_int_tree = dict [str,IntervalTree[Interval[SD]]]()
    
    sd_l = list[SD]()
    file1 = open(path, 'r')
    for i in file1.readlines():
        line = i.split('\t')

        # first we build interval tree for our SEDEF new hard_masked data (.bed file)
        if not wgac:
            if not coordinates is None:
                if not line[0] in coordinates or not line[3] in coordinates:
                    continue
                sd = SD(line[0],int(line[1]),int(line[2]),line[3],int(line[4]),int(line[5]), '', '',line[8] != line[9], line[12] )

                chr1 = line[0]
                chr2 = line[3]
                if not chr1 in dict_int_tree:
                    dict_int_tree[chr1] = IntervalTree[Interval[SD]]()
                if not chr2 in dict_int_tree:
                    dict_int_tree[chr2] = IntervalTree[Interval[SD]]()

                dict_int_tree[chr1].addi(float( int(line[1]) ) , float( int(line[2]) ) , Interval[SD]( int(line[4]), int(line[5]) , sd))
                
                dict_int_tree[chr1].addi( float ( int(line[4]) ) , float ( int(line[5]) ) , Interval[SD]( int(line[1]), int(line[2]) , sd))

                ovrlp1 = coordinates[line[0]].overlap(float(line[1]),float(line[2]))
                ovrlp2 = coordinates[line[3]].overlap(float(line[4]),float(line[5]))

                if  len(ovrlp1) > 0 or len(ovrlp2) > 0:
                    
                    sum__ = 0
                    for i_ in ovrlp1:
                        sum__ += int(i_.end - i_.begin)
                        
                        sd.clade.add(i_.data)
                    for i_ in ovrlp2:
                        sum__ += int(i_.end - i_.begin)

                        sd.clade.add(i_.data)
                    if sum__ > (sd.mate1.end - sd.mate1.begin + sd.mate2.end - sd.mate2.begin) * 0: #.1:
                        sd_l.append(sd)

                    assert len(sd.clade) > 0
                



            if coordinates is None: 
                sd = SD(line[0],int(line[1]),int(line[2]),line[3],int(line[4]),int(line[5]), '', '',line[8] != line[9])
                sd_l.append(sd)

                chr1 = line[0]
                chr2 = line[3]
                if not chr1 in dict_int_tree:
                    dict_int_tree[chr1] = IntervalTree[Interval[SD]]()
                if not chr2 in dict_int_tree:
                    dict_int_tree[chr2] = IntervalTree[Interval[SD]]()
                dict_int_tree[chr1][ int(line[1]) : int(line[2]) ]  = Interval[SD]( int(line[4]), int(line[5]) , sd)
                dict_int_tree[chr2][ int(line[4]) : int(line[5]) ]  = Interval[SD]( int(line[1]), int(line[2]) , sd)
        else:
            if abs(int(line[8]) - int(line[7])) <= 1:
                continue
            sd = SD(line[0],int(line[1]),int(line[2]),line[6],int(line[7]),int(line[8]), '', '',line[5] != '+')
            sd_l.append(sd)

            chr1 = line[0]
            chr2 = line[6]
            if not chr1 in dict_int_tree:
                dict_int_tree[chr1] = IntervalTree[Interval[SD]]()
            if not chr2 in dict_int_tree:
                dict_int_tree[chr2] = IntervalTree[Interval[SD]]()
            dict_int_tree[chr1][ int(line[1]) : int(line[2]) ]  = Interval[SD]( int(line[7]), int(line[8]) , sd)
            dict_int_tree[chr2][ int(line[7]) : int(line[8]) ]  = Interval[SD]( int(line[1]), int(line[2]) , sd)

    return dict_int_tree, sd_l

def get_min(sd_l, labels):
    min_value = 99.0
    min_indexes = (0,0)
    for i in range(0,len(sd_l)):
        if labels[i] == -1:
            continue
        for j in range(i + 1,len(sd_l)):
            if i == j or labels[j] == -1:
                continue
            # here calculate similarities
            distance = sd_l[i][j]
            
            
            if distance < min_value:
                min_value = distance
                min_indexes = (i,j)

    return min_value, min_indexes


def pritn_matrix(matrix):
    for i in matrix:
        print (i)

def add_recalculate(sim_matrix, i_, j_, clade_weights, labels):

    assert labels[i_] != -1 and labels[j_] != -1

    labels[i_] = -1
    labels[j_] = -1
    labels.append(len(labels))

    clade_weights.append(clade_weights[i_] + clade_weights[j_])

    for i in range(0, len(sim_matrix)):
        distance = (clade_weights[i_] * sim_matrix[i_][i] + clade_weights[j_] *  sim_matrix[j_][i]) / (clade_weights[i_] + clade_weights[j_])
        if labels[i] != -1:
            sim_matrix[i].append(distance)
        else:
            sim_matrix[i].append(2.0)
    
    l_h = list[float]()
    for i in range(0, len(sim_matrix)):
        l_h.append(sim_matrix[i][-1])
    l_h.append(-1.0)
    sim_matrix.append(l_h)

def how_many_neg(labels):
    count = 0
    for i in labels:
        if i == -1:
            count+=1
    return count





def print_matrix(distance_matrix):
    s = ','
    for i in range(0,len(distance_matrix)):
        s += f'{i}'
        if i != len(distance_matrix) -1:
            s += f','
    s+='\n'
    for i in range(0,len(distance_matrix)):
        s+=f'{i},'
        print i
        for j in range(0,len(distance_matrix)):
            s+= f'{distance_matrix[i][j]}'
            if j != len(distance_matrix) - 1:
                s += f','
        s+='\n'
    print s
    return s



import sys





def group():

    # first create interval tree for SDs
    path_sds = '/home/hiseric1/new_sedef/biser/src/results/5_all/same/hg19_hg19/final.bed' # 'same8/hg19_hg19/final.bed' # 'different8/final_all.bed' #'data/wgac_hard_aligned_2.bed'
    elementary_path = '/home/hiseric1/new_sedef/biser/src/align/results/hg19_5_2/elementaries_hg19.bed' # '/home/hiseric1/new_sedef/biser/src/align/results/hg19_5_m/elementaries.bed' # '/home/hiseric1/new_sedef/biser/src/align/results/hg19_5_2/elementaries_hg19.bed' # 'data/cores/out_hg19_new.txt' #'test/final.bed'
    

    coordinates =  ('hg19#chr16', 7631444, 7639283)

    distance_matrix = list[list[float]]()

    elem_dict = dict[str, list[tuple[str, int,int, str]]]()

    # second, assign to each interval its corresponding clades
    
    cores__ = list[int]()
    for i in open(elementary_path,'r'):
        # after that, we can build similarity matrix based on shared elemetnary sds]
        line = i.split('\t')
        
        clade = line[3]
        chr1 = line[0] #[:-1]
        start = int(line[1])
        end = int(line[2])

        if clade in elem_dict:
            elem_dict[clade].append((chr1, start, end, clade))
        else:
            elem_dict[clade] = [(chr1, start, end, clade)]
    print f'done reading elementaries {len(cores__)}, {len(elem_dict)}'
    for_saving = list[str]()
    for_saving_set = dict[str, int]()


    coverage1 = 0
    coordinates2 = [('hg19#chr16', 10446237, 10586220), ('hg19#chr16', 10964013, 11083747), ('hg19#chr16', 10624870, 10780247), ('hg19#chr16', 14204340, 14346299), ('hg19#chr16', 30346381, 30446477), ('hg19#chr16', 7577687 ,7903370)]
    for key in elem_dict:
        for list_elem in elem_dict[key]:
            for i__ in coordinates2:
                if list_elem[0] == i__[0]: 
                    if list_elem[1] < i__[2] and list_elem[2] > i__[1]:
                        coverage1 += list_elem[2] - list_elem[1]
                        for_saving.append(key)
                        if key in for_saving_set:
                            for_saving_set[key] += 1
                        else:
                            for_saving_set[key] = 1

                        print list_elem
    for_saving = list[str](set[str](for_saving))
    print coverage1, coordinates[2] -  coordinates[1], len(for_saving), len(set(for_saving))
    print 'One:'
    max_ = 0
    max_elem = ''
    for i in for_saving_set:
        if max_ < for_saving_set[i]:
            max_ = for_saving_set[i]
            max_elem = i
    print 'Here:'
    for i in elem_dict[max_elem]:
        print i

    print f'Build for saving keys '

    small_int_tree = dict[str,IntervalTree[str]]()
    for key in for_saving:
        for list_elem in elem_dict[key]:
            if list_elem[0] in small_int_tree:
                small_int_tree[list_elem[0] ].add(Interval(list_elem[1],list_elem[2],list_elem[3]))
            else:
                small_int_tree[list_elem[0] ] = IntervalTree[str]()
                small_int_tree[list_elem[0] ].add(Interval(list_elem[1],list_elem[2],list_elem[3]))

    print 'built small interv tree'
    
    # now get all SDs that overlap these elementary
    dict_int_t, sd_l = getIntTree(path_sds, False, small_int_tree)

    min_indexes = (0,0)
    min_value = -1
    out = open('results/output_distances1.txt', 'w')
    out_sds = open('results/output_sds1.txt', 'w')


    print f' len of sd_l : {len(sd_l)}'
    out.write(f'{len(sd_l)}\n')
    for i in range(0,len(sd_l)):
        rev_c = '-' if sd_l[i].is_rev else '+'
        out_sds.write(f'{sd_l[i].mate1.chr_}\t{sd_l[i].mate1.begin}\t{sd_l[i].mate1.end}\t{sd_l[i].mate2.chr_}\t{sd_l[i].mate2.begin}\t{sd_l[i].mate2.end}\t\t+\t{rev_c}\t{sd_l[i].cigar}\n')
        distance_matrix.append(list[float]())
        for j in range(i+1,len(sd_l)):
            distance = 2.0
            # here calculate similarities

            if i != j:
                distance =  1 - ( len( sd_l[i].clade.intersection(sd_l[j].clade) ) / len( sd_l[i].clade.union( sd_l[j].clade ) ) )
                if distance != 1:
                    out.write(f'{i}\t{j}\t{distance}\n')
    out.close()
    out_sds.close()


def group_specific_regions():
    path_sds = '/home/hiseric1/new_sedef/biser/src/results/npip_hard.txt' # '/home/hiseric1/new_sedef/biser/src/results/chimp_hard6.txt' # '/home/hiseric1/new_sedef/biser/src/results/npip_hard.txt' # 'same8/hg19_hg19/final.bed' # 'different8/final_all.bed' #'data/wgac_hard_aligned_2.bed'
    elementary_path = '/home/hiseric1/new_sedef/biser/src/results/hg19_elems_100mn/elementaries.bed' # '/home/hiseric1/new_sedef/biser/src/results/panTro6_decomp/elementaries.bed' # '/home/hiseric1/new_sedef/biser/src/align/results/final_elems/elementaries.bed' # '/home/hiseric1/new_sedef/biser/src/align/results/hg19_5_2/elementaries_hg19.bed' # '/home/hiseric1/new_sedef/biser/src/align/results/hg19_5_m/elementaries.bed' # '/home/hiseric1/new_sedef/biser/src/align/results/hg19_5_2/elementaries_hg19.bed' # 'data/cores/out_hg19_new.txt' #'test/final.bed'
    distance_matrix = list[list[float]]()

    elem_dict = dict[str, list[tuple[str, int,int, str, str]]]()

    for i in open(elementary_path,'r'):
        # after that, we can build similarity matrix based on shared elemetnary sds]
        line = i.split('\t')
        
        clade = line[3]
        chr1 = line[0] #[:-1]
        start = int(line[1])
        end = int(line[2])
        strand = (line[6])



        if clade in elem_dict:
            elem_dict[clade].append((chr1, start, end, clade, strand))
        else:
            elem_dict[clade] = [(chr1, start, end, clade, strand)]
    
    coordinates2 = []
    print 'elems loaded'
    species = 'hg19#'
    for i in open(path_sds, 'r').readlines():

        chr_,coordinates_1, coordinates_2, npip_k = i.split(' ')

        coordinates2.append( ( species+chr_, int(coordinates_1), int(coordinates_2), npip_k, list[tuple[int,int, str, str]]() ) )

    for_saving = list[str]()
    for key in elem_dict:
        for list_elem in elem_dict[key]:
            for i__ in coordinates2:
                if list_elem[0] == i__[0]:

                    if list_elem[1] > i__[1] and list_elem[2] < i__[2]: 
                        for_saving.append(key)
                        i__[4].append((list_elem[1], list_elem[2] - list_elem[1], key,list_elem[4] ))
                        
    for_saving = list[str](set[str](for_saving))

    out = open('results/output_distances_hg19_100.txt', 'w')
    out_sds = open('results/output_hg19_100.txt', 'w')


    # print 'Building matrix:'
    print f' len of sd_l : {len(coordinates2)}'
    out.write(f'{len(coordinates2)}\n')
    for i in range(0,len(coordinates2)):
        # print i, len(sd_l)
        coordinates2[i][4].sort()
        out_sds.write(f'{coordinates2[i][0]}\t{coordinates2[i][1]}\t{coordinates2[i][2]}\t{coordinates2[i][3]}\t{coordinates2[i][4]}\n')
        distance_matrix.append(list[float]())
        for j in range(i+1,len(coordinates2)):
            distance = 2.0
            # here calculate similarities

            if i != j:
                set1 = set()
                set2 = set()
                for i__ in coordinates2[i][4]:
                    set1.add(i__[2])
                for i__ in coordinates2[j][4]:
                    set2.add(i__[2])
                distance =  1 - ( len( set1.intersection(set2) ) / len( set1.union( set2) ) )
                if distance != 1:
                    out.write(f'{i}\t{j}\t{distance}\n')
    out.close()
    out_sds.close()
        

with timing('all'):
    # group()
    group_specific_regions()