from bio import CIGAR
import sys
from time import timing
from IntervalTree.intervaltree import *


chrsIds = dict[int, str]()
def merge_overlaps_1(l1: list[Interval[bool]]):

    l1.sort()

    skip_these = set[int]()
    delete_these = set[int]()
    final_sds = list[Interval[bool]]()


    i = 0
    while i < len(l1):
        if i in skip_these:
            i+= 1
            continue
        
        j = i+1
        while j < len(l1) and l1[i].end >= l1[j].begin:
            if not j in skip_these:
                
                if l1[i].overlaps(l1[j]):
                    merged = Interval[bool](min(l1[i].begin, l1[j].begin), max(l1[i].end, l1[j].end), True)
                    skip_these.add(j)
                    l1[i] = merged


            j+=1
        final_sds.append(l1[i])
        i += 1
    
    return final_sds
    
class Dot:
    chr: int
    pos: int
    def __init__(self, chr:str, pos:int):
        self.chr = chr
        self.pos = pos
    # , sd_id : int
    def __hash__(self):
        return tuple[int,int](self.chr, self.pos).__hash__()
    def __eq__(self, other):
        return self.chr == other.chr and self.pos == other.pos
    def __ne__(self, other):
        return self.chr != other.chr or self.pos != other.pos
    def __lt__(self: Dot, other: Dot):
        return (self.chr, self.pos) < (other.chr, other.pos)
    def __gt__(self: Dot, other: Dot):
        return (self.chr, self.pos) > (other.chr, other.pos)
    def __ge__(self: Dot, other: Dot):
        return (self.chr, self.pos) >= (other.chr, other.pos)
    def __le__(self: Dot, other: Dot):
        return (self.chr, self.pos) <= (other.chr, other.pos)
    def __str__(self, ):
        return f'{self.chr}, {self.pos}'
class Pos:
    chr: int
    start: int
    end: int
    def __init__(self, chr, start, end):
        self.chr = chr
        self.start = start
        self.end = end



class SD:
    id: int
    mate1: Pos
    mate2: Pos
    reversed: bool
    cigar: CIGAR
    inv_d_i: bool
    whole_line: str

    def __init__(self: SD, p1: Pos, p2: Pos, reversed: bool, cigar: CIGAR):
        self.mate1 = p1
        self.mate2 = p2
        self.reversed = reversed
        self.cigar = cigar
        self.inv_d_i = True
    def __init__(self: SD, p1: Pos, p2: Pos, reversed: bool, cigar: CIGAR, inv_d_i: bool):
        self.mate1 = p1
        self.mate2 = p2
        self.reversed = reversed
        self.cigar = cigar
        self.inv_d_i = inv_d_i
    def __init__(self: SD, p1: Pos, p2: Pos, reversed: bool, cigar: CIGAR, whole_line: str):
        self.mate1 = p1
        self.mate2 = p2
        self.reversed = reversed
        self.cigar = cigar
        self.whole_line = whole_line
    
    def get_first(self:SD, possible_extension = 0):
        c1, s1, e1 = self.mate1.chr, self.mate1.start, self.mate1.end
        c2, s2, e2 = self.mate2.chr, self.mate2.start, self.mate2.end
        return (Dot(c1, s1 - possible_extension), Dot(c2,s2 - possible_extension))
    def get_last(self: SD, possible_extension = 0):
        c1, s1, e1 = self.mate1.chr, self.mate1.start, self.mate1.end
        c2, s2, e2 = self.mate2.chr, self.mate2.start, self.mate2.end
        
        e1 -= 1
        e2 -= 1
        return (Dot(c1, e1 + possible_extension), Dot(c2,e2 + possible_extension ))

    def get_all_dots(self: SD, possible_extension = 0) -> tuple[list[Dot], list[Dot]]:
        c1, s1, e1 = self.mate1.chr, self.mate1.start, self.mate1.end
        c2, s2, e2 = self.mate2.chr, self.mate2.start, self.mate2.end
        # print s1, e1, s2,e2
        assert s1 < e1
        assert s2 < e2

        l1 = list[Dot]()
        for i in range(s1 - possible_extension,e1 + possible_extension):
            l1.append(Dot(c1, i))

        l2 = list[Dot]()
        for i in range(s2 - possible_extension,e2 + possible_extension):
            l2.append(Dot(c2, i))
        return (l1,l2)
    def get_pairs(self: SD) -> tuple[Dot, Dot]:
        c1, s1, e1 = self.mate1.chr, self.mate1.start, self.mate1.end
        c2, s2, e2 = self.mate2.chr, self.mate2.start, self.mate2.end
        dir = 1
        if self.reversed:
            s2 = e2 - 1
            dir = -1
        for sz, op in self.cigar:
            # print sz, op
            if op == 'M':
                for i in range(sz):
                    yield Dot(c1, s1), Dot(c2, s2)
                    s1 += 1
                    s2 += dir
            elif op == 'D': #D I
                # yield Dot(c1, s1), Dot(c2, s2)
                s1 += sz
            elif op == 'I': #I D
                # yield Dot(c1, s1), Dot(c2, s2)
                s2 += dir * sz
        # print s1, s2, e1, e2
        assert s1 == e1 
    def get_pairs_3(self: SD) -> tuple[list[Dot], list[Dot]]:
        c1, s1, e1 = self.mate1.chr, self.mate1.start, self.mate1.end
        c2, s2, e2 = self.mate2.chr, self.mate2.start, self.mate2.end
        l1 = list[Dot]()
        l2 = list[Dot]()
        threshold = 0

        d__ = 'D' if self.inv_d_i else 'I'
        i__ = 'I' if self.inv_d_i else 'D'

        dir = 1
        if self.reversed:
            s2 = e2 - 1
            dir = -1
        for sz, op in self.cigar:
            # print sz, op
            if op == 'M':
                for i in range(sz):
                    l1.append(Dot(c1, s1))
                    l2.append(Dot(c2, s2))
                    s1 += 1
                    s2 += dir
            elif op == i__: #D I
                if sz < threshold:
                    for i in range(sz):
                        l1.append(Dot(c1, s1))
                        l2.append(Dot(c2, s2))
                        s1 += 1
                else:
                    s1 += sz
            elif op == d__: #I D
                if sz < threshold:
                    for i in range(sz):
                        l1.append(Dot(c1, s1))
                        l2.append(Dot(c2, s2))
                        s2 += dir
                else:
                    s2 += dir * sz
        # print s1, s2, e1, e2
        assert s1 == e1 
        return (l1, l2)
    def get_pairs_2(self: SD) -> tuple[Dot, Dot]:
        c1, s1, e1 = self.mate1.chr, self.mate1.start, self.mate1.end
        c2, s2, e2 = self.mate2.chr, self.mate2.start, self.mate2.end
        dir = 1
        if self.reversed:
            s2 = e2 - 1
            dir = -1
        for sz, op in self.cigar:
            # print sz, op
            if op == 'M':
                for i in range(sz):
                    yield Dot(c1, s1), Dot(c2, s2)
                    s1 += 1
                    s2 += dir
            elif op == 'I': #D
                for i in range(sz):
                    yield Dot(c1, s1), Dot(c2, s2)
                    s1 += 1
            elif op == 'D': #I
                for i in range(sz):
                    yield Dot(c1, s1), Dot(c2, s2)
                    s2 += dir
        # print s1, s2, e1, e2
        assert s1 == e1 
    def __str__(self: SD):
        return f'{self.mate1}\t{self.mate2}\t{self.reversed}'

