import sys
from time import time
from bio import FASTA, Kmer, CIGAR
from time import timing
from chain import chain
from merge import Hit


def generate_anchors(x, y, same_chr, xstart, ystart, KMER_SIZE: Static[int] = 10):
  ref_hashes = {}
  for pos, kmer in y.kmers_with_pos(1, KMER_SIZE):
    ref_hashes.setdefault(int(kmer), []).append(pos)

  slide = [-1] * (len(x) + len(y))
  for xi, kmer in x.kmers_with_pos(1, KMER_SIZE):
    matches = ref_hashes.get(int(kmer), [])
    if not 0 < len(matches) < 1000:
      continue
    for yi in matches:
      d = len(x) + yi - xi
      if (same_chr and abs(ystart + yi - xstart - xi) <= KMER_SIZE) or xi < slide[d]:
        continue
      ext = KMER_SIZE
      while (
        xi + ext < len(x) and yi + ext < len(y) and
        x[xi + ext] != s'N' and y[yi + ext] != s'N' and x[xi + ext] == y[yi + ext]
      ):
        ext += 1
      yield (xi, yi, ext)
      slide[d] = xi + ext





def fill_alignments(
  x, y, anchors, hit,
  MATCH =  6 + -5,
  MISMATCH =  6 + 4,
  GAP_OPEN =  6 + 40,
  GAP_EXTEND = 6 + 1
):  
  cigar = []
  for hi in range(len(hit) - 1):
    a, an = anchors[hit[hi]], anchors[hit[hi + 1]]
    cigar.append(f'{a[2]}M')
    xg, yg = an[0] - a[0] - a[2], an[1] - a[1] - a[2]
    if xg == 0:
      cigar.append(f'{yg}I')
    elif yg == 0:
      cigar.append(f'{xg}D')
    elif max(xg, yg) <= 1000:
      cigar.append(str(x[a[0] + a[2]:an[0]].align(y[a[1] + a[2]:an[1]], MATCH, MISMATCH, gapo=GAP_OPEN, gape=GAP_EXTEND).cigar))
    else:
      mi, ma = min(xg, yg), max(xg, yg)
      al = x[a[0] + a[2]:a[0] + a[2] + mi].align(y[a[1] + a[2]:a[1] + a[2] + mi], MATCH, MISMATCH, gapo=GAP_OPEN, gape=GAP_EXTEND)
      ar = x[an[0] - mi:an[0]].align(y[an[1] - mi:an[1]], MATCH, MISMATCH, gapo=GAP_OPEN, gape=GAP_EXTEND)
      gc = f"{ma - mi}{'DI'[int(xg == mi)]}"
      if al.score < ar.score:
        cigar += [str(al.cigar), gc]
      else:
        cigar += [gc, str(ar.cigar)]
  cigar.append(f'{anchors[hit[-1]][2]}M')
  return ''.join(cigar)


if __name__ == '__main__':
  chromosomes = {}
  with FASTA(sys.argv[1]) as fa:
    for r in fa:
      chromosomes[r.name] = r.seq

  with timing("align"), open(sys.argv[2]) as f:
    # hits = []
    for li, lp in enumerate(f):
      h = Hit(lp)
      x = chromosomes[h.x.chr.split('#')[1]][h.x.start:h.x.end]
      y = chromosomes[h.y.chr.split('#')[1]][h.y.start:h.y.end] if not h.rc else ~chromosomes[h.y.chr.split('#')[1]][h.y.start:h.y.end]
      anchors = list(generate_anchors(x, y, h.x.chr == h.y.chr and not h.rc, h.x.start, h.y.start))
      for ch in chain(anchors):
        c = fill_alignments(x, y, anchors, ch)
        print(li, h.x.start + anchors[ch[0]][0], h.y.start + anchors[ch[0]][1], c)

    #   if li%100==0:
    #     print(f'\r{li}', file=sys.stderr)
    # print(f'\ndone!', file=sys.stderr)


def refine(x, y, hits, h):
  MATCH = 10
  MISMATCH = 1
  GAP = 0.5
  GAPOPEN = 100 # try to approximate WGAC
  MIN_READ = 900 # minimal refined read size
  SIDE_ALIGN = 500 
  MAX_GAP = 10 * 1024 # max gap during refining process
  
  hits.sort()
  same_chr = h.x.name == h.y.name and not h.rc

  score = [MATCH * h.match() - MISMATCH * h.mismatch() - GAP * h.gap() for h in hits]
  dp, prev = [0] * len(hits), [-1] * len(hits)
  maxes = set()
  for ai, a in enumerate(hits):
    if same_chr:
      qo = min(h.x.start + a.x.end, h.y.start + a.y.end) - max(h.x.start + a.x.start, a.y.start + a.y.start)
      if max(a.y.end - a.y.start, a.x.end - a.x.start) - max(qo, 0) < SIDE_ALIGN:
        continue # no gap inbetween
    dp[ai] = score[ai]
    for aj in range(ai - 1, -1, -1):
      c, p = hits[ai], hits[aj]
      cqs = p.x.end if c.x.start < p.x.end else c.x.start
      crs = p.y.end if c.y.start < p.y.end else c.y.start
      if p.x.end >= c.x.end or p.y.end >= c.y.end or p.y.start >= c.y.start: 
        continue

      mi, ma = min(cqs - p.x.end, crs - p.y.end), max(cqs - p.x.end, crs - p.y.end)
      if ma >= MAX_GAP:
        continue
      if same_chr and max(0, min(h.x.start + cqs, h.y.start + crs) - max(h.x.start + p.x.end, h.y.start + p.y.end)) >= 1:
        continue # no gap between
      score = dp[aj] + score[ai] - MISMATCH * mi - GAPOPEN - GAP * (ma - mi)
      if score >= dp[ai]:
        dp[ai], prev[ai] = score, aj
    maxes.insert((dp[ai], ai))

    # stage 2

    used = [False] * len(hits)
    paths = []
    results = []
    for d, maxi in maxes:
      if d == 0: break
      if used[maxi]: continue

      path = []
      while maxi != -1 and not used[maxi]:
        paths.append(maxi)
        used[maxi] = True
        maxi = prev[maxi]
      path = path[::-1]

      est_size = hits[path[0]].aln.span()
      for i in range(1, len(path)):
        est_size += hits[path[i]].aln.span()
        est_size += max(
          hits[path[i]].x.start - hits[path[i - 1]].x.end,
          hits[path[i]].y.start - hits[path[i - 1]].y.end
        )
      if est_size < MIN_READ - SIDE_ALIGN:
        continue

      xs, xe = hits[path[0]].x.start, hits[path[-1]].x.end
      ys, ye = hits[path[0]].y.start, hits[path[-1]].y.end
      if any(
        xe - xs - max(0, min(xe, r.x.end) - max(xs, r.x.start)) < SIDE_ALIGN and
        ye - ys - max(0, min(ye, r.y.end) - max(ys, r.y.start)) < SIDE_ALIGN
        for r in results
      ):
        continue
      
      # h = 

