import sys
import math
import getopt
import collections
import bio
import os
import time


KMER_SIZE = 14
WINNOW_SIZE = 16
TAU = 0.0
QUERY_THRESHOLD = 300
REF_THRESHOLD = 1_000
MAX_EXTEND = 5_000
MAX_DISTANCE = 250
INDEX_CUTOFF = 0.001
MAX_SD_LEN = 2_000_000_000
MAX_ERROR = 0.3
MAX_EDIT_ERROR = 0.15


@dataclass(eq=True)
class Chromosome:
    id: int
    species: str
    name: str
    complement: bool = False
    len: int = 0

    def __str__(self):
        return f'{self.species}_{self.name}'


@tuple
class Locus:
    chr: int  # Chromosome ID
    loc: int


class ListNode:
    """Main class that holds information about nodes in linked list"""

    first: int
    last: int
    ref: int
    ref_last: int
    chr: int
    age: int = 0
    count: int = 0
    next: Optional[ListNode] = None
    potentional: bool = False

    def insert_after(self, first, ref, chr, age = 1, count = 1):
        self.next = ListNode(first, first, ref, ref, chr, age, count, self.next)

    def __iter__(self):
        walker: Optional[ListNode] = self
        while walker:
            yield walker
            walker = walker.next

    def __str__(self):
        return ''.join(
            f"({i.first}:{i.last}; ref: {i.ref}, {i.chr}; {i.age}/{i.count}; "
            f"{i.potentional})->"
            for i in self
        )

    def __len__(self):
        return sum(1 for _ in self)


def tau():
    ratio = (MAX_ERROR - MAX_EDIT_ERROR) / MAX_EDIT_ERROR
    gap_error = min(1.0, ratio * MAX_EDIT_ERROR)
    a = (1 - gap_error) / (1 + gap_error)
    b = 1 / (2 * math.exp(KMER_SIZE * MAX_EDIT_ERROR) - 1)
    return a * b


def save_sd(L, current, chromosomes, result):
    def pad_sd(chromosomes, c1, b1, e1, c2, b2, e2):
        b1 = max(0, b1 - MAX_EXTEND)
        e1 = min(chromosomes[c1].len - 1, e1 + MAX_EXTEND)
        if c1 == c2: e1 = min(e1, b2)
        b2 = max(0, b2 - MAX_EXTEND)
        if c1 == c2: b2 = max(b2, e1)
        e2 = min(chromosomes[c2].len - 1, e2 + MAX_EXTEND)
        return (b1, e1, b2, e2)
    
    if L.chr < len(chromosomes) and current.chr < len(chromosomes):
        chr1, chr2 = chromosomes[L.chr], chromosomes[current.chr]
        coord = (0, 0, 0, 0)
        complement = int(chr1.complement or chr2.complement)
        if complement and str(chr1) == str(chr2):
            coord = pad_sd(chromosomes, L.chr, L.first, L.last, current.chr, chr2.len - current.loc, chr2.len - L.ref)
        elif complement:
            coord = pad_sd(chromosomes, L.chr, chr1.len - L.last, chr1.len - L.first, current.chr, L.ref, current.loc)
        else:
            coord = pad_sd(chromosomes, L.chr,  L.first, L.last, current.chr, L.ref, current.loc)
        name = f"{chr1}_{chr2}_{'ny'[complement]}.bed"
        result.setdefault(name, []).append(
            f"{chr1.species}#{chr1.name}\t{coord[0]}\t{coord[1]}\t"
            f"{chr2.species}#{chr2.name}\t{coord[2]}\t{coord[3]}\t"
            f"\t\t+\t{'+-'[complement]}"
        )
    else:
        raise ValueError("reverse complemented intervals should not be here")


def update_list(L: Optional[ListNode], loci, current, chromosomes, result):
    loci_idx = 0

    # if certain values in the beginning of the loci are lower that first node, add them all beforehand
    walker, previous, holder = L, L, L
    while (
        L and loci_idx < len(loci)
        and (
            (loci[loci_idx].chr == L.chr and loci[loci_idx].loc < L.first)
            or (loci[loci_idx].chr < L.chr)
        )
    ):
        if not (
            loci_idx < len(loci)
            and chromosomes[current.chr].complement
            and loci[loci_idx].chr != current.chr - 1
        ):
            walker = ListNode(loci[loci_idx].loc, loci[loci_idx].loc, current.loc, current.loc, loci[loci_idx].chr, 1, 1, L)
            if previous is not L:
                previous.next = walker
            if loci_idx == 0:
                holder = walker
            previous = walker
        loci_idx += 1

    walker, previous, L = L, L, holder
    while walker:
        if (
            loci_idx < len(loci)
            and chromosomes[current.chr].complement
            and loci[loci_idx].chr != current.chr - 1
        ):
            loci_idx += 1
            continue

        delete = False
        if (
            loci_idx < len(loci)
            and walker.ref != current.loc
            and walker.last < loci[loci_idx].loc
            and walker.last + MAX_DISTANCE >= loci[loci_idx][1]
            and walker.chr == loci[loci_idx].chr
        ):
            walker.last = loci[loci_idx].loc
            walker.ref_last = current.loc
            walker.count += 1
            loci_idx += 1
        elif loci_idx < len(loci) and (
            not walker.next
            or (
                loci[loci_idx][0] < walker.next.chr
                or (
                    walker.next.first >= loci[loci_idx].loc
                    and walker.next.chr == loci[loci_idx].chr
                )
            )
        ):
            # We set age to 0, we will increase it to one when we are on this node
            walker.insert_after(loci[loci_idx].loc, current.loc, loci[loci_idx].chr, 0, 1)
            if loci[loci_idx].chr == walker.chr and walker.first < loci[loci_idx].loc < walker.last:
                walker.age += 1
            loci_idx += 1
            continue

        walker.age += 1
        condition = walker.count >= math.ceil(walker.age * TAU)
        if condition and (walker.last - walker.first) < MAX_SD_LEN:
            walker.potentional = True
        elif not condition or walker.last - walker.first >= MAX_SD_LEN:
            if walker.potentional:
                # for last was previously used walker.first + current - walker.ref
                # (< walker.ref -> for checking how close they are?)
                if current.loc - walker.ref >= REF_THRESHOLD and walker.last - walker.first > QUERY_THRESHOLD:
                    save_sd(walker, Locus(current.chr, walker.ref_last), chromosomes, result)
            if walker is L:
                L = L.next
            else:
                if walker.next is None:
                    previous.next = None
                else:
                    delete = True  # delete node
                    previous.next = walker.next
        if not delete:
            previous = walker
        walker = walker.next

    while loci_idx < len(loci):
        if not (
            loci_idx < len(loci)
            and chromosomes[current.chr].complement
            and loci[loci_idx].chr != current.chr - 1
        ):
            if not L:
                previous = L = ListNode(loci[0].loc, loci[0].loc, current.loc, current.loc, loci[0].chr, 1, 1)
            else:
                previous.insert_after(loci[loci_idx].loc, current.loc, loci[loci_idx].chr)
                previous = previous.next
        loci_idx += 1
    return L


def build_index(
    s: bio.seq,
    chr: int,
    index: Dict[int, List[Locus]], # kmer -> [(chr, loc)]
    chromosomes,
    result,
    find_sds = False,
    build_index = False,
    max_frequency = (1 << 32) - 1,
):
    MASK = (1 << (2 * KMER_SIZE)) - 1

    L = None # ListNode
    processed_kmer_count = 0

    winnow = []
    h, last_hash = 0, -1  # Hash(-1,0)
    for i, si in enumerate(s): # TODO: use seq k-mers
        h = ((h << 2) | (int(si) & 3)) & MASK
        if i < KMER_SIZE - 1:
            continue
        # here we ensure that correct elements are in winnow
        while winnow and not (winnow[-1][0] < h):
            winnow.pop()
        while winnow and winnow[-1][1] < (i - KMER_SIZE + 1) - WINNOW_SIZE:
            winnow.pop(0)
        winnow.append((h, i - KMER_SIZE + 1))
        if i - KMER_SIZE + 1 < WINNOW_SIZE:
            continue
        if len(index) == 0 or winnow[0][0] != last_hash:
            processed_kmer_count += 1
            hash = winnow[0][0]
            if hash in index:
                if find_sds:
                    if len(index[hash]) < max_frequency:
                        L = update_list(L, index[hash], Locus(chr, winnow[0][1]), chromosomes, result)
                if build_index:
                    index[hash].append(Locus(chr, winnow[0][1]))
            elif build_index:
                index[hash] = [Locus(chr, winnow[0][1])]
            last_hash = hash

    if find_sds:
        for i in L:
            if i.potentional and (i.last - i.first > QUERY_THRESHOLD or i.count >= 4):
                save_sd(i, Locus(chr, i.ref_last), chromosomes, result)

    return processed_kmer_count


def valid_chr(chr):
    return "_" not in chr and chr != "chrM"

def biser_search(ref_path, query_path, ref_chr):
    """
    this is main function for parallel call if one chr is specified,
    it finds all SDs within that chr and between that chr and all other chromosomes
    that are lexicographically bigger than it
    """

    species = ref_path.split("/")[-1].split('.')[0].split("_")[0]
    index = {} # Dict[ int, List[Tuple[int, int]] ]
    result: Dict[str, List[str]] = {} # 
    # here we first build dictionary and find potential regions in reference chromosome
    chromosomes = []
    if not ref_chr:
        assert query_path != ref_path
        with bio.FASTA(ref_path) as fr:
            for i in fr:
                if valid_chr(i.name):
                    chromosomes.append(Chromosome(len(chromosomes), species, i.name))
                    chromosomes.append(Chromosome(len(chromosomes), species, i.name, True))
    else:
        chromosomes.append(Chromosome(len(chromosomes), species, ref_chr))
        chromosomes.append(Chromosome(len(chromosomes), species, ref_chr, True))
    frequency = 0
    with bio.FASTA(ref_path) as fr:
        for chr_index, chr in enumerate(chromosomes):
            ref = ~fr[chr.name] if chr.complement else fr[chr.name]
            chr.len = len(ref)
            frequency = build_index(
                ref,
                chr_index,
                index,
                chromosomes,
                result,
                build_index=True,
                find_sds=ref_path == query_path,
            )

    # Now we find matching subsequences in all other chromosomes that are bigger than 
    # out ref_chr if both specie are same, if not, take all chromosomes from another specie
    hist, max_len = {}, 0
    for loci in index.values():
        hist[len(loci)] = hist.get(len(loci), 0) + 1
        max_len = max(max_len, len(loci))
    sum, occurence, threshold = 0, 0, 1 << 31
    for i in sorted(hist.keys(), reverse=True):
        sum += hist[i]
        if sum <= int(frequency * INDEX_CUTOFF):
            threshold = i
            occurence += hist[i]
        else:
            break
    print(f"filtered {occurence} k-mers")

    # here we read all other chromosomes:
    begin = len(chromosomes)
    species = query_path.split("/")[-1].split('.')[0].split("_")[0]
    with bio.FASTA(query_path) as fr:
        for i in fr:
            if valid_chr(i.name):
                if query_path != ref_path or i.name > ref_chr:
                    chromosomes.append(Chromosome(len(chromosomes), species, i.name))
                    chromosomes.append(Chromosome(len(chromosomes), species, i.name, True))
    with bio.FASTA(query_path) as fr:
        for chr_index in range(begin, len(chromosomes)):
            chr = chromosomes[chr_index]
            ref = ~fr[chr.name] if chr.complement else fr[chr.name]
            chr.len = len(ref)
            build_index(
                ref,
                chr_index,
                index,
                chromosomes,
                result,
                build_index=False,
                find_sds=True,
                max_frequency=threshold,
            )
    return result

if __name__ == "__main__":
    out, threads = 'biser_search.bed', 1
    opts, args = getopt.getopt(sys.argv[1:], "k:w:o:p:r:q:t:")
    for o, a in opts:
        if o in ("-k", "--kmer"):
            KMER_SIZE = int(a)
        elif o in ("-w", "--winnow"):
            WINNOW_SIZE = int(a)
        elif o in ("-o", "--output"):
            out = a
            if a[-1] != "/": out += "/"
        elif o in ("-p", "--padding"):
            MAX_EXTEND = int(a)
        elif o in ("-r", "--ref"):
            REF_THRESHOLD = int(a)
        elif o in ("-q", "--query"):
            QUERY_THRESHOLD = int(a)
        elif o in ("-t", "--threads"):
            THREADS = int(a)
    if len(args) < 2:
        print("Wrong formatting")
    fa1, fa2, chr1 = args + ["", ""]
    print(f"Input: {fa1}\t{fa2}\t{chr1}, {KMER_SIZE}, {WINNOW_SIZE}")
    TAU = tau()

    with time.timing("Search"):    
        chromosomes = [i.name for i in bio.FASTA(fa1) if valid_chr(i.name)]
        results = {c: {} for c in chromosomes}
        # @par(num_threads=threads)
        for c in chromosomes:
            results[c] = biser_search(fa1, fa2, c)
        with open(out, "w") as f:
            for _, r in results.items():
                for i in r:
                    print(i, file=f)
