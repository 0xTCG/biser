import sys
import bisect
import time
import bio
from math import round


MERGE_DIST = 500
MATCH = 5 
MISMATCH = -4
GAPO = -40
GAPE = -1

def align(x, y):
  MAX_ALIGN = 20 * 1000
  s, c = 0, []
  for oi in range(0, max(len(x), len(y)), MAX_ALIGN):
    a = bio.seq.align(
      x[oi:oi + MAX_ALIGN], y[oi:oi + MAX_ALIGN], 
      a=MATCH, b=-MISMATCH, gapo=-GAPO, gape=-GAPE
    )
    xi, yi = oi, oi
    for l, op in a.cigar:
      if op == 'M':
        i = 0
        while i < l:
          j, eq = 0, x[xi + i] == y[yi + i]
          while i < l and (x[xi + i] == y[yi + i]) == eq:
            i += 1; j += 1
          c.append((j, '=' if eq else 'X'))
        xi += l; yi += l
      elif op == 'I':
        c.append((l, op)); xi += l
      elif op == 'D':
        c.append((l, op)); yi += l
    s += a.score
  return s, c


class Chromosome:
  species: str
  name: str
  rc: bool
  seq: bio.seq
  
  def __init__(self, s: str, rc: bool):
    self.species, self.name = s.split('#')
    self.rc = rc
    self.seq = bio.seq()

  def __eq__(self, o: Chromosome):
    return (self.species, self.name, self.rc) == (o.species, o.name, o.rc)
  def __ne__(self, o: Chromosome):
    return not self == o
  def __lt__(self, o: Chromosome):
    return (self.species, self.name, self.rc) < (o.species, o.name, o.rc)
  
  def __getitem__(self, s):
    if isinstance(s, slice): assert s.step is None
    return ~(self.seq[s]) if self.rc else self.seq[s]


@dataclass(eq=True, order=True)
class Hit:
  @dataclass(eq=True, order=True)
  class Interval:
    chr: Chromosome
    start: int
    end: int
  
  x: Interval
  y: Interval
  cigar: List[Tuple[int, str]]

  def __init__(self, h: Hit):
    self.x = Interval(h.x.chr, h.x.start, h.x.end)
    self.y = Interval(h.y.chr, h.y.start, h.y.end)
    self.cigar = copy(h.cigar)
  def __init__(self, s: str, chromosomes: Optional[Dict[Tuple[str, bool], Chromosome]] = None):
    l = s.strip().split('\t')
    if chromosomes:
      self.x = Interval(chromosomes[l[0], l[8] == '-'], int(l[1]), int(l[2]))
      self.y = Interval(chromosomes[l[3], l[9] == '-'], int(l[4]), int(l[5]))
    else:
      self.x = Interval(Chromosome(l[0], l[8] == '-'), int(l[1]), int(l[2]))
      self.y = Interval(Chromosome(l[3], l[9] == '-'), int(l[4]), int(l[5]))
    if self.y < self.x: 
      self.y, self.x = self.x, self.y
    self.cigar = []
  def __init__(self, h: Hit, anchor: Tuple[int, int, int]):
    self.x = Interval(h.x.chr, anchor[0], anchor[0] + anchor[2])
    self.y = Interval(h.y.chr, anchor[1], anchor[1] + anchor[2])
    self.cigar = [(anchor[2], '=')]
  def __init__(self, h: Hit, anchors: List[Hit], side = 0):
    self.x = Interval(h.x.chr, anchors[0].x.start, anchors[-1].x.end)
    self.y = Interval(h.y.chr, anchors[0].y.start, anchors[-1].y.end)
    self.cigar = []
    prev = anchors[0]
    for a in anchors[1:]:
      if a.x.start < prev.x.end or a.y.start < prev.y.end:
        prev.extend(a)
        continue
      self.cigar += prev.cigar
      self.cigar += self.align_gap(prev.x.end, a.x.start, prev.y.end, a.y.start) 
      prev = a
    self.cigar += prev.cigar
    
    if side > 0:
      off = min(side, self.x.start, self.y.start)
      self.cigar = align(
        h.x.chr[self.x.start - off:self.x.start], h.y.chr[self.y.start - off:self.y.start]
      )[1] + self.cigar
      self.x.start -= off; self.y.start -= off
      self.ltrim()

      off = min(side, len(self.x.chr.seq) - self.x.end, len(self.y.chr.seq) - self.y.end)
      self.cigar += align(
        h.x.chr[self.x.end:self.x.end + off], h.y.chr[self.y.end:self.y.end + off]
      )[1]
      self.x.end += off; self.y.end += off
      self.rtrim()

  def collapse_cigar(self):
    c, pl, po = [], 0, ''
    for l, o in self.cigar:
      if po and o != po:
        c.append((pl, po))
      if o == po:
        pl += l
      else:
        pl, po = l, o
    c.append((pl, po))
    self.cigar = c

  def __str__(self):
    return (
      f"{self.x.chr.name}\t{self.x.start}\t{self.x.end}\t" # coordinates
      f"{self.y.chr.name}\t{self.y.start}\t{self.y.end}\t"
      f"\t{round(100 * self.err(), 1)}\t"
      f"{'+-'[int(self.x.chr.rc)]}\t{'+-'[int(self.y.chr.rc)]}\t" # strands
      f"{max(self.y.end - self.y.start, self.x.end - self.x.start)}\t" # max span
      f"{self.span()}\t{self.simple_cigar()}\t" # span and cigar
      f"X={round(100 * self.mis_err(), 1)};ID={round(100 * self.gap_err(), 1)}" # mismatch/gap
    )
  
  def simple_cigar(self):
    c, i = [], 0
    while i < len(self.cigar):
      l = 0
      while i < len(self.cigar) and self.cigar[i][1] in '=X':
        l += self.cigar[i][0]; i += 1
      if l > 0: 
        c.append(f'{l}M')
      else:
        c.append(f'{self.cigar[i][0]}{"I" if self.cigar[i][1] == "D" else "D"}')
        i += 1
    return ''.join(c)
  
  def __lt__(self, o: Hit):
    return (self.x.chr, self.y.chr, self.x, self.y) < (o.x.chr, o.y.chr, o.x, o.y)
  def __eq__(self, o: Hit):
    return (self.x, self.y) == (o.x, o.y)
  
  def __iter__(self):
    x, y = self.x.start, self.y.start
    for l, op in self.cigar:
      yield x, y, l, op
      match op: 
        case 'X' | '=': x += l; y += l
        case 'I': x += l
        case 'D': y += l

  def nice(self):
    a, m, b = [], [], []
    for x, y, l, op in self:
      match op:
        case 'X' | '=': 
          a.append(str(self.x.chr[x:x+l])); b.append(str(self.y.chr[y:y+l]))
          m.append(('|' if op == '=' else '*') * l)
        case 'I':
          a.append(str(self.x.chr[x:x+l])); b.append('-' * l)
          m.append('*' * l)
        case 'D':
          a.append('-' * l); b.append(str(self.y.chr[y:y+l]))
          m.append('*' * l)
      # a.append(' ');b.append(' ');m.append(' ')
    print(''.join(a))
    print(''.join(m))
    print(''.join(b))

  def score(self, match, mismatch, gap):
    total = 0.0
    for l, op in self.cigar:
      match op:
        case 'X': total += mismatch * l
        case '=': total += match * l
        case 'I' | 'D': total += gap * l
    return total

  def span(self):
    return sum(l for l, _ in self.cigar)

  def gap_err(self):
    return sum(l for l, o in self.cigar if o in 'ID') / float(self.span())
  def mis_err(self):
    return sum(l for l, o in self.cigar if o == 'X') / float(self.span())
  def err(self):
    return self.gap_err() + self.mis_err()

  def align_gap(self, xs, xe, ys, ye):
    if xe - xs == 0:
      return [(ye - ys, 'D')]
    elif ye - ys == 0:
      return [(xe - xs, 'I')]
    elif max(xe - xs, ye - ys) <= 20:
      return align(self.x.chr[xs:xe], self.y.chr[ys:ye])[1]
    else:
      mi, ma = min(xe - xs, ye - ys), max(xe - xs, ye - ys)
      al = align(self.x.chr[xs:xs + mi], self.y.chr[ys:ys + mi])
      ar = align(self.x.chr[xe - mi:xe], self.y.chr[ye - mi:ye])
      gc = (ma - mi, 'ID'[int(xe - xs == mi)])
      if al[0] > ar[0]:
        return al[1] + [gc]
      else:
        return [gc] + ar[1]

  def same_chr(self):
    return self.x.chr == self.y.chr

  def extend(self, other):
    # WARN: modifies other!
    # I: *- (insertion in first seq) ; D: -* (deletion in first seq)

    assert other.x.start < self.x.end or other.y.start < self.y.end
    assert self.x.end <= other.x.end and self.y.end <= other.y.end

    ocig = [o for l, o in other.cigar for _ in range(l)]
    bi = 0
    for i in range(self.x.end - other.x.start):
      while bi < len(ocig) and ocig[bi] == 'D':
        other.y.start += 1
        bi += 1
      other.x.start += 1
      if ocig[bi] != 'I':
        other.y.start += 1
      bi += 1
    for i in range(self.y.end - other.y.start):
      while bi < len(ocig) and ocig[bi] == 'I':
        other.x.start += 1
        bi += 1
      other.y.start += 1
      if ocig[bi] != 'D':
        other.x.start += 1
      bi += 1
    
    self.cigar += self.align_gap(self.x.end, other.x.start, self.y.end, other.y.start)
    c = 0
    for i in range(bi, len(ocig)):
      c += 1
      if i == len(ocig) - 1 or ocig[i + 1] != ocig[i]:
        self.cigar.append((c, ocig[i]))
        c = 0
    self.x.end, self.y.end = other.x.end, other.y.end

  def ltrim(self):  # ABCD -> --CD
    s, maxs = 0, 0
    maxi = len(self.cigar), self.x.end, self.y.end
    for ci, (x, y, l, o) in enumerate(list(self)[::-1]):
      match o:
        case '=': s += l * MATCH
        case 'X': s += l * MISMATCH
        case 'I' | 'D': s += GAPO + l * GAPE
      if s >= maxs:
        maxs, maxi = s, (len(self.cigar) - ci - 1, x, y)
    self.cigar = self.cigar[maxi[0]:]
    self.x.start, self.y.start = maxi[1], maxi[2]

  def rtrim(self):  # ABCD -> AB--
    s, maxs = 0, 0
    maxi = 0, self.x.start, self.y.start
    for ci, (x, y, l, o) in enumerate(self):
      match o:
        case '=': s += l * MATCH
        case 'X': s += l * MISMATCH
        case 'I' | 'D': s += GAPO + l * GAPE
      if s >= maxs:
        maxs, maxi = s, (ci + 1, x + l, y + l)
    self.cigar = self.cigar[:maxi[0]]
    self.x.end, self.y.end = maxi[1], maxi[2]


def merge(hits):
  hits.sort()
  y_sorted, y_hits = [], []
  ph = Hit()
  for hi, h in enumerate(hits):
    if h.same_chr():
      continue
    if hi == 0:
      y_sorted, y_hits = [h.y.end], [Hit(h)]
      ph = Hit(h)
      continue
    elif ph.x.end + MERGE_DIST < h.x.start or ph.x.chr != h.x.chr or ph.y.chr != h.y.chr:
      yield from y_hits
      y_sorted, y_hits = [h.y.end], [Hit(h)]
      ph = Hit(h)
    else:
      while True:
        update = False
        s = bisect.bisect_left(y_sorted, h.y.start - MERGE_DIST)
        while s < len(y_sorted):
          if (
            y_hits[s].x.end + MERGE_DIST >= h.x.start and
            y_hits[s].y.end + MERGE_DIST >= h.y.start and
            h.y.end + MERGE_DIST >= y_hits[s].y.start
          ):
            h.x.end = max(h.x.end, y_hits[s].x.end)
            h.y.end = max(h.y.end, y_hits[s].y.end)
            h.x.start = min(h.x.start, y_hits[s].x.start)
            h.y.start = min(h.y.start, y_hits[s].y.start)
            del y_sorted[s], y_hits[s]
            update = True
          else:
            s += 1
        if not update:
          break
      i = bisect.bisect_left(y_sorted, h.y.end)
      y_sorted.insert(i, h.y.end)
      y_hits.insert(i, Hit(h))
      h.x.end = max(h.x.end, ph.x.end)
      ph = Hit(h)
  yield from y_hits

if __name__ == "__main__":
  with time.timing('Merge'), open(sys.argv[1], 'w') as f:
    for path in sys.argv[2:]:
      print(f'processing {path}...')
      hits = [Hit(l) for l in open(path)]
      for h in merge(hits):
        print(h, file=f)
