import sys
import math
import getopt
import collections
import bio
import os
import bisect
import time
from hit import Hit


KMER_SIZE = 14
WINNOW_SIZE = 16
TAU = 0.0
QUERY_THRESHOLD = 300
REF_THRESHOLD = 1_000
MAX_EXTEND = 5_000
MAX_DISTANCE = 250
INDEX_CUTOFF = 0.001
MAX_SD_LEN = 2_000_000_000
MAX_ERROR = 0.3
MAX_EDIT_ERROR = 0.15
MERGE_DIST = 500


@dataclass(eq=True)
class Chromosome:
  id: int
  species: str
  name: str
  complement: bool = False
  len: int = 0

  def __str__(self):
    return f'{self.species}_{self.name}'


@tuple
class Locus:
  chr: int  # Chromosome ID
  loc: int


class ListNode:
  """Main class that holds information about nodes in linked list"""

  first: int
  last: int
  ref: int
  ref_last: int
  chr: int
  age: int = 0
  count: int = 0
  next: Optional[ListNode] = None
  potentional: bool = False

  def insert_after(self, first, ref, chr, age = 1, count = 1):
    self.next = ListNode(first, first, ref, ref, chr, age, count, self.next)

  def __iter__(self):
    walker: Optional[ListNode] = self
    while walker:
      yield walker
      walker = walker.next

  def __str__(self):
    return ''.join(
      f"({i.first}:{i.last}; ref: {i.ref}, {i.chr}; {i.age}/{i.count}; "
      f"{i.potentional})->"
      for i in self
    )

  def __len__(self):
    return sum(1 for _ in self)


def tau():
  ratio = (MAX_ERROR - MAX_EDIT_ERROR) / MAX_EDIT_ERROR
  gap_error = min(1.0, ratio * MAX_EDIT_ERROR)
  a = (1 - gap_error) / (1 + gap_error)
  b = 1 / (2 * math.exp(KMER_SIZE * MAX_EDIT_ERROR) - 1)
  return a * b


def save_sd(L, cur, chrs, result):
  def pad_sd(chrs, c1, b1, e1, c2, b2, e2):
    b1 = max(0, b1 - MAX_EXTEND)
    e1 = min(chrs[c1].len - 1, e1 + MAX_EXTEND)
    if c1 == c2: e1 = min(e1, b2)
    b2 = max(0, b2 - MAX_EXTEND)
    if c1 == c2: b2 = max(b2, e1)
    e2 = min(chrs[c2].len - 1, e2 + MAX_EXTEND)
    return (b1, e1, b2, e2)
  
  if L.chr < len(chrs) and cur.chr < len(chrs):
    chr1, chr2 = chrs[L.chr], chrs[cur.chr]
    coord = (0, 0, 0, 0)
    complement = chr1.complement or chr2.complement
    # TODO: just use normal coordinates
    if complement and str(chr1) == str(chr2):
      coord = pad_sd(
        chrs, L.chr, L.first, L.last, cur.chr, chr2.len - cur.loc, chr2.len - L.ref
      )
    elif complement:
      coord = pad_sd(
        chrs, L.chr, chr1.len - L.last, chr1.len - L.first, cur.chr, L.ref, cur.loc
      )
    else:
      coord = pad_sd(chrs, L.chr, L.first, L.last, cur.chr, L.ref, cur.loc)
    result[chr1.species, chr1.name, chr2.species, chr2.name, complement].append(
      Hit(
        chr1.species, chr1.name, coord[0], coord[1], False,
        chr2.species, chr2.name, coord[2], coord[3], complement
      )
    )
  else:
    raise ValueError("reverse complemented intervals should not be here")


def update_list(L: Optional[ListNode], loci, current, chromosomes, result):
  lidx = 0

  # if certain values in the beginning of the loci are lower that first node, 
  # add them all beforehand
  walker, previous, holder = L, L, L
  while L and lidx < len(loci) and (loci[lidx].chr, loci[lidx].loc) < (L.chr, L.first):
    if not (
      lidx < len(loci)
      and chromosomes[current.chr].complement
      and loci[lidx].chr != current.chr - 1
    ):
      walker = ListNode(
        loci[lidx].loc, loci[lidx].loc,
        current.loc, current.loc, 
        loci[lidx].chr, 1, 1, L
      )
      if previous is not L:
        previous.next = walker
      if lidx == 0:
        holder = walker
      previous = walker
    lidx += 1

  walker, previous, L = L, L, holder
  while walker:
    if (
      lidx < len(loci)
      and chromosomes[current.chr].complement
      and loci[lidx].chr != current.chr - 1
    ):
      lidx += 1
      continue

    if (
      lidx < len(loci)
      and walker.ref != current.loc
      and walker.chr == loci[lidx].chr
      and loci[lidx][1] - MAX_DISTANCE <= walker.last < loci[lidx].loc
    ):
      walker.last = loci[lidx].loc
      walker.ref_last = current.loc
      walker.count += 1
      lidx += 1
    elif lidx < len(loci) and (
      not walker.next
      or (
        loci[lidx][0] < walker.next.chr
        or (walker.next.chr == loci[lidx].chr and walker.next.first >= loci[lidx].loc)
      )
    ):
      # We set age to 0, we will increase it to one when we are on this node
      walker.insert_after(loci[lidx].loc, current.loc, loci[lidx].chr, 0, 1)
      if loci[lidx].chr == walker.chr and walker.first < loci[lidx].loc < walker.last:
        walker.age += 1
      lidx += 1
      continue

    walker.age += 1
    condition = walker.count >= math.ceil(walker.age * TAU)
    delete = False
    if condition and (walker.last - walker.first) < MAX_SD_LEN:
      walker.potentional = True
    elif (not condition) or walker.last - walker.first >= MAX_SD_LEN:
      if walker.potentional:
        # for last was previously used walker.first + current - walker.ref
        # (< walker.ref -> for checking how close they are?)
        if (
          current.loc - walker.ref >= REF_THRESHOLD and 
          walker.last - walker.first > QUERY_THRESHOLD
        ):
          save_sd(walker, Locus(current.chr, walker.ref_last), chromosomes, result)
      if walker is L:
        L = L.next
      elif walker.next is None:
        previous.next = None
      else:
          delete = True
          previous.next = walker.next
    if not delete:
      previous = walker
    walker = walker.next

  while lidx < len(loci):
    if not (
      lidx < len(loci)
      and chromosomes[current.chr].complement
      and loci[lidx].chr != current.chr - 1
    ):
      if not L:
        previous = L = ListNode(
          loci[0].loc, loci[0].loc, current.loc, current.loc, loci[0].chr, 1, 1
        )
      else:
        previous.insert_after(loci[lidx].loc, current.loc, loci[lidx].chr)
        previous = previous.next
    lidx += 1
  return L


def build_index(
  s: bio.seq,
  chr: int,
  index: Dict[int, List[Locus]], # kmer -> [(chr, loc)]
  chromosomes,
  result,
  find_sds = False,
  build_index = False,
  max_frequency = (1 << 32) - 1,
):
  MASK = (1 << (2 * KMER_SIZE)) - 1

  L = None
  processed_kmer_count = 0

  winnow = []
  h, last_hash = 0, -1  # Hash(-1,0)
  for i, si in enumerate(s): # TODO: use seq k-mers
    h = ((h << 2) | (int(si) & 3)) & MASK
    if i < KMER_SIZE - 1:
      continue
    # here we ensure that correct elements are in winnow
    while winnow and not (winnow[-1][0] < h):
      winnow.pop()
    while winnow and winnow[-1][1] < (i - KMER_SIZE + 1) - WINNOW_SIZE:
      winnow.pop(0)
    winnow.append((h, i - KMER_SIZE + 1))
    if i - KMER_SIZE + 1 < WINNOW_SIZE:
      continue
    if len(index) == 0 or winnow[0][0] != last_hash:
      processed_kmer_count += 1
      hash = winnow[0][0]
      if hash in index:
        if find_sds:
          if len(index[hash]) >= max_frequency:
            continue
          L = update_list(L, index[hash], Locus(chr, winnow[0][1]), chromosomes, result)
        if build_index:
          index[hash].append(Locus(chr, winnow[0][1]))
      elif build_index:
        index[hash] = [Locus(chr, winnow[0][1])]
      last_hash = hash

  if find_sds and L:
    for i in L:
      if i.potentional and (i.last - i.first > QUERY_THRESHOLD or i.count >= 4):
        save_sd(i, Locus(chr, i.ref_last), chromosomes, result)
  return processed_kmer_count


def valid_chr(chr):
  return "_" not in chr and chr != "chrM"

def biser_search(ref_path, query_path, ref_chr, result):
  """
  this is main function for parallel call if one chr is specified,
  it finds all SDs within that chr and between that chr and all other chromosomes
  that are lexicographically bigger than it
  """

  species = ref_path.split("/")[-1].split('.')[0].split("_")[0]
  index = {} # Dict[ int, List[Tuple[int, int]] ]
  # here we first build dictionary and find potential regions in reference chromosome
  chromosomes = []
  frequency = 0
  if not ref_chr:
    assert query_path != ref_path
    with bio.FASTA(ref_path) as fr:
      for i in fr:
        if valid_chr(i.name):
          chromosomes.append(Chromosome(len(chromosomes), species, i.name))
          chromosomes.append(Chromosome(len(chromosomes), species, i.name, True))
  else:
    chromosomes.append(Chromosome(len(chromosomes), species, ref_chr))
    chromosomes.append(Chromosome(len(chromosomes), species, ref_chr, True))
  
  with bio.FASTA(ref_path) as fr:
    for chr_index, chr in enumerate(chromosomes):
      ref = ~fr[chr.name] if chr.complement else fr[chr.name]
      chr.len = len(ref)
      frequency = build_index(
        ref,
        chr_index,
        index,
        chromosomes,
        result,
        build_index=True,
        find_sds=ref_path == query_path,
      )

  # Now we find matching subsequences in all other chromosomes that are bigger than 
  # out ref_chr if both specie are same, if not, take all chromosomes from another specie
  hist, max_len = {}, 0
  for loci in index.values():
    hist[len(loci)] = hist.get(len(loci), 0) + 1
    max_len = max(max_len, len(loci))
  sum, occurence, threshold = 0, 0, 1 << 31
  for i in sorted(hist.keys(), reverse=True):
    sum += hist[i]
    if sum <= int(frequency * INDEX_CUTOFF):
      threshold = i
      occurence += hist[i]
    else:
      break
  print(f"filtered {occurence} k-mers")

  # here we read all other chromosomes:
  species = query_path.split("/")[-1].split('.')[0].split("_")[0]
  with bio.FASTA(query_path) as fr:
    for i in fr:
      if valid_chr(i.name) and (query_path != ref_path or i.name > ref_chr):
        chromosomes.append(Chromosome(len(chromosomes), species, i.name))
        chromosomes[-1].len = len(i.seq)
        build_index(
          i.seq,
          len(chromosomes) - 1,
          index,
          chromosomes,
          result,
          build_index=False,
          find_sds=True,
          max_frequency=threshold,
        )


def merge(hits, dist):
  hits.sort(
    key=lambda h: (h.y.chr.rc, h.x.chr.name, h.y.chr.name, h.x.start, h.y.start)
  )
  y_sorted, y_hits = [], []
  ph = Hit()
  for hi, h in enumerate(hits):
    assert not h.x.chr.rc
    if h.x == h.y:
      continue
    if hi == 0 or ph.x.end + dist < h.x.start or ph.x.chr != h.x.chr or ph.y.chr != h.y.chr:
      yield from y_hits
      y_sorted, y_hits = [h.y.end], [Hit(h)]
    else:
      while True:
        update = False
        s = bisect.bisect_left(y_sorted, h.y.start - dist)
        while s < len(y_sorted):
          if (
            y_hits[s].x.end + dist >= h.x.start and
            y_hits[s].y.end + dist >= h.y.start and
            y_hits[s].y.start <= h.y.end + dist
          ):
            h.x.end = max(h.x.end, y_hits[s].x.end)
            h.y.end = max(h.y.end, y_hits[s].y.end)
            h.x.start = min(h.x.start, y_hits[s].x.start)
            h.y.start = min(h.y.start, y_hits[s].y.start)
            del y_sorted[s], y_hits[s]
            update = True
          else:
            s += 1
        if not update:
          break
      i = bisect.bisect_left(y_sorted, h.y.end)
      y_sorted.insert(i, h.y.end)
      y_hits.insert(i, Hit(h))
    h.x.end = max(h.x.end, ph.x.end)
    ph = Hit(h)
  yield from y_hits


if __name__ == "__main__":
  with time.timing("Main"):
    out, THREADS = 'biser_search.bed', 1
    opts, args = getopt.getopt(sys.argv[1:], "k:w:o:p:r:q:t:")
    for o, a in opts:
      if o in ("-k", "--kmer"):
        KMER_SIZE = int(a)
      elif o in ("-w", "--winnow"):
        WINNOW_SIZE = int(a)
      elif o in ("-o", "--output"):
        out = a
      elif o in ("-p", "--padding"):
        MAX_EXTEND = int(a)
      elif o in ("-r", "--ref"):
        REF_THRESHOLD = int(a)
      elif o in ("-q", "--query"):
        QUERY_THRESHOLD = int(a)
      elif o in ("-t", "--threads"):
        THREADS = int(a)
    if len(args) < 2:
      print("Wrong formatting")
    fa1, fa2, chr1 = args + ["", ""]
    print(f"Input: {fa1}\t{fa2}\t{chr1}, {KMER_SIZE}, {WINNOW_SIZE}")
    TAU = tau()

    species = fa1.split("/")[-1].split('.')[0].split("_")[0]
    chromosomes = [i.name for i in bio.FASTA(fa1) if valid_chr(i.name)]    
    result = {
      (species, c, species, d, r): List[Hit]()
      for c in chromosomes for d in chromosomes for r in [True, False]
      if c <= d
    }
    if chr1 != '':
      with time.timing("Search"):  
        biser_search(fa1, fa2, chr1, result)
      with open(out, "w") as f:
        k = []
        for i in result.values(): k += i
        for h in merge(k, MERGE_DIST):
          print(h, file=f)
    else:
      with time.timing("Search"):  
        @par(num_threads=THREADS, schedule='dynamic')
        for c in chromosomes:
          with time.timing(f"search_{c}"):
            biser_search(fa1, fa2, c, result)
    # with time.timing("Merge"), open(out, "w") as f:
      # for _, l in result.items():
        # for h in merge.merge(l):
          # print(h, file=f)
